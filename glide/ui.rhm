#lang rhombus

import:
  rhombus/meta open
  pict open
  pict/text open
  pict/rhombus open
  gui expose:
    ~>
    <~

import:
  "stx_helpers.rhm" open

let initialScreenW = 1700
let initialScreenH = 800 

let aspect_ratio = 16 / 9

fun scale_to_fit(pict, size):
  let scaleW = size[0] / pict.width
  let scaleH = size[1] / pict.height
  let scale = math.min(scaleW, scaleH)
  pict.scale(scale)

fun scale_to_width(pict, width):
  let scale = width / pict.width
  pict.scale(scale)

fun mini_slide(pict):
  rectangle(~around: pict, ~line_width: 4).pad(~left: 0.025 * initialScreenW, ~top: 0.025 * initialScreenH, ~right: 0.025 * initialScreenW, ~bottom: 0.025 * initialScreenH)

class Tab(scrollBarPos):
  method pict(canvas_size, picts, tab_screen_width):
    let mini_slide_size = tab_screen_width * 0.8 * canvas_size.width
    let plus_slide = scale_to_width(mini_slide(text("+")), mini_slide_size)

    let combined:
      for values(res = nothing):
        each:
          pict in (picts ++ [plus_slide])
        stack(res, scale_to_width(mini_slide(pict), mini_slide_size))

    [combined.pad(~left: tab_screen_width * 0.1 * canvas_size.width, ~right: tab_screen_width * 0.1 * canvas_size.width), plus_slide]

  method draw(dc, picts, tab_screen_width):
    // draw the pict on the left side of the screen
    this.pict(dc.size, picts, tab_screen_width)[0].draw(dc)


class TabsPict(pict, plus_button, tab_buttons)

// INVARIANT: number of tabs is the same as number
// of tabs in code, plus one for the slides
class UI(selected, config, original_config_stx, tabs, tab_screen_width, selected_tab, current_slide_index):
  method draw(dx, inputState, current_rendered):
    if this.selected:
    | block:
        let selected_pict = find_pict_from_gpi(current_rendered.selected_slide, this.selected)
        let (x, y) = Find(selected_pict, ~horiz: #'left, ~vert: #'top).in(current_rendered.selected_slide)
        let width = selected_pict.width
        let height = selected_pict.height
        rectangle(~width: width, ~height: height, ~fill: #false, ~line: "blue", ~line_width: 4).pad(~left: x, ~top: y).draw(dx)
    | #false

    // todo draw selected tab
    this.tabs_pict(dx.size, current_rendered).pict.draw(dx)

  method tab_tools(current_rendered):
    if this.selected_tab+1 == this.tabs.length()
    | current_rendered.slides
    | current_rendered.tabs[this.selected_tab]

  method tabs_pict(canvas_size, current_rendered):
    let [current_tab, plus_button] = this.tabs[this.selected_tab].pict(canvas_size, this.tab_tools(current_rendered), this.tab_screen_width)

    // now draw clickable tabs on the side for each one
    let tabs:
      for List:
        each:
          tab in this.tabs
          i in 0..
        overlay(rectangle(~width: canvas_size.width * 0.03, ~height: canvas_size.height * 0.1, ~fill: "white", ~line: "black", ~line_width: 4),
                text(to_string(i)))

    let stacked:
      for values(res = nothing):
        each:
          tab in tabs
        stack(res, tab)
    let res:
      beside(~sep: 0, current_tab, stacked)
    
    TabsPict(res, plus_button, tabs)

  // return a new UI after a mouse event
  method on_mouse(ev, current_rendered, canvas_size):
    let tabs_pict = this.tabs_pict(canvas_size, current_rendered)
    let current_tab = this.tabs[this.selected_tab]
    if ev.kind == gui.MouseEvent.Kind.left_down:
    | block:
        let clicked:
          for any:
            each:
              pict in current_rendered.slides
              i in 0..
            println("checking " +& i)
            if is_pict_clicked(tabs_pict.pict, pict, ev)
            | i
            | #false
        println("clicked: " +& clicked)
        if clicked:
        | this with (current_slide_index = clicked)
        | if is_pict_clicked(tabs_pict.pict, tabs_pict.plus_button, ev)
          | this with (current_slide_index = current_rendered.slides.length())
          | this
    | this

export:
  initialScreenW
  initialScreenH
  aspect_ratio
  UI
  Tab
  scale_to_fit
