#lang rhombus


import:
  rhombus/meta open
  pict open
  pict/text open
  pict/rhombus open
  rhombus/measure
  rhombus/runtime_path
  rhombus/fixnum expose:
    - as fm
  gui expose:
    ~>
    <~




fun replace_const(stx, newnum):
  match stx:
  | '$name ($arg, ...)':
      '$name ($(replace_const(arg, newnum)), ...)'
  | '~width: $num':
      '~width: $newnum'
  | _: stx


let screenW = 800
let screenH = 800

class Button(xpos, ypos, width, height):
  method draw(dc, inputState):
    let screenx = xpos * dc.height
    let screeny = ypos * dc.height
    let screenw = width * dc.height
    let screenh = height * dc.height
    let color:
      if this.isCursorIn(inputState)
      | "gray"
      | "white"

    rectangle(~width: width*dc.height, ~height: height*dc.height, ~fill: color, ~line: "black", ~line_width: 3).pad(~left: screenx, ~right: screeny).draw(dc)

  method isCursorIn(inputState):
    let screenx = xpos * screenH
    let screeny = ypos * screenH
    let screenw = width * screenH
    let screenh = height * screenH
    inputState.mouseX > screenx && inputState.mouseY > screeny && inputState.mouseX < screenx+screenw && inputState.mouseY < screeny+screenh  
    

class InputState(mouseX, mouseY)

class UI(buttons):
  method draw(dx, inputState):
    for (button in buttons):
      button.draw(dx, inputState)

// code is the current code for the body of the function
class Glide(inputState, code, old_code, ui, file_path):
  method onmouse(ev):
    let with_input = this with (inputState = (this.inputState with (mouseX = ev.x, mouseY = ev.y)))
    with_input

  method onkey(ev):
    if ev.code == Char"s" && gui.KeyEvent.Down.control in ev.downs:
    | dosave(this)
    | "other"
    this


fun dosave(glide):
  let srcloc = glide.old_code.srcloc
  println(glide.file_path)

  #false

fun draw(dc, data):
  eval(data.code).draw(dc)
  data.ui.draw(dc, data.inputState)

  // if we need to save because data.code is different from data.old_code, draw save icon
  if data.code != data.old_code:
  | let savePict = rectangle(~width: 50, ~height: 50, ~fill: "gray", ~line: "black", ~line_width: 3).pad(~left: 750, ~top: 750)
    savePict.draw(dc)
  | #false


fun onmousefor(state):
  fun onmouse(ev :: gui.MouseEvent, area):
    state <~ fun (old): old.onmouse(ev)
  onmouse

fun onkeyfor(state):
  fun onkey(ev :: gui.KeyEvent, area):
    state <~ fun (old): old.onkey(ev)
  onkey

fun edit_slide(stx, path_name):
  let ui = UI([])
  let state = gui.Obs(Glide(InputState(0, 0), stx, stx, ui, path_name))
  

  let win = gui.Window(gui.Canvas(state, draw, ~mouse: onmousefor(state), ~key: onkeyfor(state)), ~size: [screenW, screenH])
  gui.render(win)


meta:
  fun glide(syntax, path):
    '«edit_slide('$(syntax)', $path)»'

expr.macro 'glide $path $name(): $(body :: Multi)':
  glide(body, path)

runtime_path.def my_path:
  "glide.rhm" // TODO this should be the name of the current file, how to do this?
      

glide my_path tworectangles():
  beside(~sep: 100, rectangle(), rectangle())