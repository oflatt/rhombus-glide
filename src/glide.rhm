#lang rhombus


import:
  rhombus/meta open
  pict open
  pict/text open
  pict/rhombus open
  rhombus/measure
  rhombus/fixnum expose:
    - as fm
  gui expose:
    ~>
    <~




fun replace_const(stx, newnum):
  match stx:
  | '$name ($arg, ...)':
      '$name ($(replace_const(arg, newnum)), ...)'
  | '~width: $num':
      '~width: $newnum'
  | _: stx


let screenW = 800
let screenH = 800

class Button(xpos, ypos, width, height):
  method draw(dc, inputState):
    let screenx = xpos * dc.height
    let screeny = ypos * dc.height
    let screenw = width * dc.height
    let screenh = height * dc.height
    let color:
      if this.isCursorIn(inputState)
      | "gray"
      | "white"

    rectangle(~width: width*dc.height, ~height: height*dc.height, ~fill: color, ~line: "black", ~line_width: 3).pad(~left: screenx, ~right: screeny).draw(dc)

  method isCursorIn(inputState):
    let screenx = xpos * screenH
    let screeny = ypos * screenH
    let screenw = width * screenH
    let screenh = height * screenH
    inputState.mouseX > screenx && inputState.mouseY > screeny && inputState.mouseX < screenx+screenw && inputState.mouseY < screeny+screenh  
    

class InputState(mouseX, mouseY)

class UI(buttons):
  method draw(dx, inputState):
    for (button in buttons):
      button.draw(dx, inputState)

// code is the current code for the body of the function
class Glide(inputState, code, ui):
  method onmouse(ev):
    let with_input = this with (inputState = (this.inputState with (mouseX = ev.x, mouseY = ev.y)))
    if ui.buttons[0].isCursorIn(with_input.inputState) && ev.kind == gui.MouseEvent.Kind.left_down:
    | println("clicked")
    | #false
    with_input



fun draw(dc, data):
  eval(data.code).draw(dc)
  data.ui.draw(dc, data.inputState)

fun onmousefor(state):
  fun onmouse(ev :: gui.MouseEvent, area):
    state <~ fun (old): old.onmouse(ev)
  onmouse

fun edit_slide(stx):
  let ui = UI([Button(0, 0, 0.1, 0.1)])
  let state = gui.Obs(Glide(InputState(0, 0), stx, ui))
  

  let win = gui.Window(gui.Canvas(state, draw, ~mouse: onmousefor(state)), ~size: [screenW, screenH])
  gui.render(win)


meta:
  fun glide(syntax):
    '«edit_slide('$(syntax)')»'


expr.macro 'glide $name(): $(body :: Multi)':
  glide(body)

glide tworectangles():
  beside(~sep: 100, rectangle(), rectangle())