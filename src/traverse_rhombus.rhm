#lang rhombus/static/and_meta

import:
  rhombus/meta open
  "rebuild.rhm" open
  meta:
    "rebuild.rhm" open


export:
  traverse_group


fun literal_term(stxs):
  'Syntax.literal_term($stxs)'

fun head_context(stxs):
  match stxs
  | '$head $_ ...':
      Syntax.relocate('#false', head)

fun is_literal_term(stx):
  match stx
  | 'Syntax.literal_term $_': #true
  | ~else: #false

fun is_literal_group(stx):
  match stx
  | 'Syntax.literal_group $_': #true
  | ~else: #false

fun extract_literal(stx):
  match stx
  | '$_ $_ $_($(stxs :: Multi))': stxs

fun nested([g, ...], builder, builder_stx, stxs, f):
  let [new_g, ...] = [traverse_group(g, f), ...]
  f(block:
      if (for all (new_g in [new_g, ...]):
            is_literal_group(new_g))
      | literal_term(builder([extract_literal(new_g), ...], head_context(stxs)))
      | '$builder_stx([$new_g, ...], Syntax.literal_term($(head_context(stxs))))')

fun literal_group(stxs):
  'Syntax.literal_group($stxs)'

fun group_context(g):
  Syntax.relocate_group('#false', g)

fun traverse_group(g, f) :: Syntax:
  f(block:
      let new_g = traverse_tail(g, f)
      if is_literal_group(new_g)
      | literal_group(Syntax.relocate_group(extract_literal(new_g), group_context(g)))
      | 'Syntax.relocate_group($new_g, Syntax.literal_group($(group_context(g))))')

fun is_literal_group_or_empty(stx):
  match stx
  | 'Syntax.literal()': #true
  | ~else: is_literal_group(stx)

fun literal_empty(stx):
  'Syntax.literal()'

fun traverse_tail(stxs, f):
  f(match stxs
    | '$head $tail ...':
        let new_head = traverse_term(head, f)
        let new_tail = traverse_tail('$tail ...', f)
        if is_literal_term(new_head) && is_literal_group_or_empty(new_tail)
        | literal_group(sequence_append_syntax(extract_literal(new_head), extract_literal(new_tail)))
        | 'sequence_append_syntax($new_head, $new_tail)'
    | '': literal_empty(stxs)
    | ~else: literal_group(stxs))

fun nested_alts([b, ...], stxs, f):
  let [new_b, ...] = [traverse_term(b, f), ...]
  if (for all (new_b in [new_b, ...]):
        is_literal_term(new_b))
  | literal_term(alts_syntax([extract_literal(new_b), ...], head_context(stxs)))
  | 'alts_syntax([$new_b, ...], Syntax.literal_term($(head_context(stxs))))'

fun traverse_term(stxs:: Syntax, f) :: Syntax:
  f(match stxs:
    | '($(g :: Group), ...)':
        nested([g, ...], parens_syntax, 'parens_syntax', stxs, f)
    | '[$(g :: Group), ...]':
        nested([g, ...], brackets_syntax, 'brackets_syntax', stxs, f)
    | '{$(g :: Group), ...}':
        nested([g, ...], braces_syntax, 'braces_syntax', stxs, f)
    | '«'$(g:: Group); ...'»':
        nested([g, ...], quotes_syntax, 'quotes_syntax', stxs, f)
    | ': $(g :: Group); ...':
        nested([g, ...], block_syntax, 'block_syntax', stxs, f)
    | '| $(b :: Block) | ...':
        nested_alts([b, ...], stxs, f)
    | ~else:
        literal_term(stxs))


eval(traverse_group('(beside(~sep: 100, rectangle(~width: 100), rectangle()))', fun (x):
                  print(x)
                  x)).to_source_string()


